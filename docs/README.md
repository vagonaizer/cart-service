# Cart Service

## Описание

Cart Service — это микросервис для управления корзиной пользователя. Он реализован по принципам чистой архитектуры (Clean Architecture) и легко расширяется под разные хранилища и интеграции.

## Структура проекта

```
cart-service/
├── cmd/
│   └── cart/
│       └── main.go           # Точка входа в приложение
├── config/
│   ├── config.go            # Конфигурация приложения
│   └── config.yaml          # Файл конфигурации
├── docs/
│   └── README.md            # Документация
├── internal/
│   ├── core/
│   │   └── app.go           # Инициализация приложения
│   ├── domain/
│   │   ├── cart.go          # Доменная модель корзины
│   │   ├── item.go          # Доменная модель товара
│   │   ├── ports.go         # Интерфейсы (порты)
│   │   └── product.go       # Доменная модель продукта
│   ├── infrastructure/
│   │   ├── api/
│   │   │   ├── dto/         # Data Transfer Objects
│   │   │   ├── errors/      # Обработка ошибок
│   │   │   ├── handlers.go  # HTTP-обработчики
│   │   │   └── router.go    # Маршрутизация
│   │   ├── client/
│   │   │   └── product_client.go  # Клиент сервиса продуктов
│   │   └── repository/
│   │       └── inmemory/
│   │           └── cart_repository.go  # In-memory реализация репозитория
│   └── usecase/
│       └── cart/
│           └── cart_service.go  # Бизнес-логика корзины
├── .gitignore
├── go.mod
├── go.sum
├── LICENSE
└── Makefile
```

---

## Архитектурные решения

### 1. Чистая архитектура
- **Доменный слой (`internal/domain`)**
  - Содержит бизнес-модели (`Cart`, `Item`) и интерфейсы (`CartRepository`, `ProductService`, `CartService`).
  - Не зависит ни от каких внешних библиотек или инфраструктуры.
- **Usecase слой (`internal/usecase`)**
  - Реализует бизнес-логику (например, добавление товара в корзину).
  - Работает только с интерфейсами доменного слоя.
- **Инфраструктурный слой (`internal/infrastructure`)**
  - Реализации репозиториев (например, in-memory), клиентов внешних сервисов, API-слой.
  - Зависит от внешних библиотек, но не влияет на бизнес-логику.
- **Core (`internal/core`)**
  - Сборка приложения: связывает все зависимости, инициализирует сервисы, репозитории, клиентов и роутинг.

### 2. Интерфейсы и инверсия зависимостей
- Все зависимости (репозитории, внешние сервисы) внедряются через интерфейсы.
- Это позволяет легко заменить, например, in-memory хранилище на PostgreSQL или другой источник данных.

### 3. Разделение ответственности
- Модели отвечают только за бизнес-логику (например, как добавить товар в корзину).
- Репозитории — только за хранение и извлечение агрегатов (`Cart`).
- Usecase (сервис) — за сценарии использования (например, "добавить товар", "очистить корзину").
- API — только за HTTP-интерфейс и валидацию.

---

## Как работает сервис

1. **Пользователь отправляет HTTP-запрос** (например, POST /cart/{user_id}/item/{sku_id})
2. **API-слой**
   - Валидирует входные данные
   - Вызывает соответствующий метод usecase (сервиса)
3. **Usecase (CartService)**
   - Получает корзину пользователя из репозитория
   - Если корзины нет — создаёт новую через `CreateCart`
   - Добавляет товар в корзину через метод модели `Cart.AddItem`
   - Сохраняет обновлённую корзину через `SaveCart`
4. **Репозиторий**
   - Отвечает за хранение и извлечение корзины (например, из памяти или БД)
5. **Ответ возвращается пользователю**

---

## Пример расширения

Чтобы заменить in-memory хранилище на PostgreSQL:
1. Реализуйте новый репозиторий, который реализует интерфейс `CartRepository`.
2. Подключите его в `core/app.go` вместо in-memory.
3. Бизнес-логика и API останутся неизменными.

---

## Преимущества подхода
- **Тестируемость**: бизнес-логика легко покрывается юнит-тестами (можно подменять репозитории и внешние сервисы).
- **Гибкость**: легко менять инфраструктуру без переписывания бизнес-логики.
- **Ясность**: каждый слой отвечает только за свою зону ответственности.

---

## Контакты

Вопросы и предложения: [your-email@example.com] 